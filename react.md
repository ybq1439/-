## 1-为什么 react 不推荐突变状态？

### （1）简化复杂功能：

​	不可变性使得复杂的特性更容易实现，比如 react 官网上“井字棋” 游戏的 **时间旅行功能**，其实也就是 **撤销恢复功能**，不直接去修改数据，可以使得我们 追溯到之前的历史记录。

### （2）跟踪数据的改变：

​	如果直接修改数据，那么很难跟踪到数据的改变。跟踪数据的变化需要 **可变对象** 于 **改变之前** 的版本对比，这样的话，整个对象树都需要遍历一次。

​	对于不可变数据而言，如果对象是一个新对象了，我们就认为对象发生改变了。

### （3）性能优化，确定在 react 中何时重新渲染：

​	不可变性最主要的优势在于它可以帮助我们在 React 中创建 *pure components*。我们可以很轻松的确定数据是否发生改变，从而确定何时对组件进行重新渲染。

## 2-setState 一直是异步的吗？

​	setState 更新数据的时候，分为同步更新和异步更新。

​	异步更新：在组件生命周期或者 react 合成事件中，setState 是异步更新；

​	同步更新：在 setTimerOut 或者 原生 DOM 事件中，setState 是同步更新；

​	setState 的异步其实不是指 **内部由异步代码构成**，本身执行过程和代码都是同步的，只是因为 **合成事件、钩子函数** 的执行顺序在数据更新之前，所以出现 **合成事件和钩子函数** 中无法立马获取到更新后的值。

## 3-setState 中的批量更新？

​	在 合成事件和生命周期钩子中，连续的调用 setState 只有最后一次会起作用。

## 4-说一说 hooks？

​	hook 是我们可以在 函数式组件中使用 类组件中的特性，例如 state。

### 	常用 hooks：

​		（1）useState：在函数式组件中维护状态；

​		（2）useEffect：副作用钩子，相当于是 **componentDidMount、componentDidUpdate、componentWillUnmount** 的组合；

​				仅仅传递第一个参数，函数的话，相当于是 componentDidMount、componentDidUpdate；

​				清除 effect：仅仅传递第一个参数，函数，并且函数里面返回一个函数，那么这个被返回的函数会在类似类组件 componentWillUnmount 中，组件卸载之前执行；

​				第二个参数，数组：依赖项，传递空数组则 **只有在 componentDidMount 执行**；

​		（3）useRef：`useRef` 返回一个可变的 ref 对象，其 `.current` 属性被初始化为传入的参数；

## 5-state 和 props区别？

一个组件的显示形态可以由 状态 state 和 参数 props 决定。

#### setState：

​	**`setState()`** 将对组件 state 的更改 **排入队列**，并通知 React 需要使用更新后的 state 重新渲染此组件及其子组件。setState 并不会立即去更新组件，它会一次性的去 **更新多个组件**，优点是 **性能更好，不需要频繁的调用 render 方法**。

​	推迟更新组件，也带来一个问题，我们无法立刻或者最新的数据，可以通过 setState 第二个参数实现，第二个参数是回调，会在 **数据更新、组件渲染之后** 调用，相当于 **componentDidUpdate 钩子**；

#### props：

​	基于组件化的思想，props 就是组件外部传入组件内部的参数，然后 react 单向数据流的思想，也可以理解为 props 是父组件传递给子组件的数据；特别注意 **props** 不可以在组件内部修改，需要在 **父组件中修改**，直接修改 不会重新渲染。

#### 总结：

相同点：

​	1-都是用来保存数据的；

​	2-都是对象；

​	3-他们改变都会触发组件重新渲染；

不同点：

​	1-props 是外部参数，state 是组件内部维护的；

​	2-props 在组件内部是不可修改的，但 state 在组件内部可以进行修改；