## 1-为什么 react 不推荐突变状态？

### （1）简化复杂功能：

​	不可变性使得复杂的特性更容易实现，比如 react 官网上“井字棋” 游戏的 **时间旅行功能**，其实也就是 **撤销恢复功能**，不直接去修改数据，可以使得我们 追溯到之前的历史记录。

### （2）跟踪数据的改变：

​	如果直接修改数据，那么很难跟踪到数据的改变。跟踪数据的变化需要 **可变对象** 于 **改变之前** 的版本对比，这样的话，整个对象树都需要遍历一次。

​	对于不可变数据而言，如果对象是一个新对象了，我们就认为对象发生改变了。

### （3）性能优化，确定在 react 中何时重新渲染：

​	不可变性最主要的优势在于它可以帮助我们在 React 中创建 *pure components*。我们可以很轻松的确定数据是否发生改变，从而确定何时对组件进行重新渲染。

## 2-setState 一直是异步的吗？

​	setState 更新数据的时候，分为同步更新和异步更新。

​	异步更新：在组件生命周期或者 react 合成事件中，setState 是异步更新；

​	同步更新：在 setTimerOut 或者 原生 DOM 事件中，setState 是同步更新；

​	setState 的异步其实不是指 **内部由异步代码构成**，本身执行过程和代码都是同步的，只是因为 **合成事件、钩子函数** 的执行顺序在数据更新之前，所以出现 **合成事件和钩子函数** 中无法立马获取到更新后的值。

## 3-setState 中的批量更新？

​	在 合成事件和生命周期钩子中，连续的调用 setState 只有最后一次会起作用。

## 4-说一说 hooks？

​	hook 是我们可以在 函数式组件中使用 类组件中的特性，例如 state。

### 	常用 hooks：

​		（1）useState：在函数式组件中维护状态；

​		（2）useEffect：副作用钩子，相当于是 **componentDidMount、componentDidUpdate、componentWillUnmount** 的组合；

​				仅仅传递第一个参数，函数的话，相当于是 componentDidMount、componentDidUpdate；

​				清除 effect：仅仅传递第一个参数，函数，并且函数里面返回一个函数，那么这个被返回的函数会在类似类组件 componentWillUnmount 中，组件卸载之前执行；

​				第二个参数，数组：依赖项，传递空数组则 **只有在 componentDidMount 执行**；

​		（3）useRef：`useRef` 返回一个可变的 ref 对象，其 `.current` 属性被初始化为传入的参数；

