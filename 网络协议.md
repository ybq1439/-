## 1-get 请求与 post 请求的区别？

1-使用场景不同：get 请求用于向服务端获取资源，一般不会对服务端造成影响，Post 请求一般用于提交数据，可能会对服务端造成影响；

2-使用场景不同，所以浏览器会主动缓存 get 请求；

3-报文格式方面，get 请求的 body 为空，而 post 请求，body 中一般就是向服务端传递的数据；get 请求也可以通过 url 传递数据；get 请求因为使用 url 携带参数，而浏览器会限制 url 长度，所以参数多少是有限制的，post 不会有长度限制；

4-参数数据类型：get 只接受 ASCII 字符，而 post 可以是很多类型没有限制；

5-安全性方面，post 相比与 get 更加安全，因为 get 请求的参数直接暴露在 url 上；

6-浏览器保存浏览记录的时候，会把 get 请求携带的参数也保存下来，post 请求不会；

安全性：http 明文传输都是不安全的，https 才安全；

## 2-SSL 连接断开，如何恢复？

1-使用 sessionId：下一次重新连接的时候，只需要客户端携带上正确的 sessionId，服务端有记录，那么还是可以使用上一次的密钥；缺点是 sessionId 是存在与服务器上的，如果请求转移到的别的服务器上，就无法恢复；

2-使用 session ticket：session ticket 服务端发送给客户端，这个 ticket 只有服务端可以解密，这样的会，如果请求到别的服务器上，也是可以恢复对话的。

## 3-http1.0、http1.1、http2.0 的区别？

http1.0：浏览器与服务器只保持短暂的连接，浏览器每一次请求都需要重新建立连接；

http1.1：

​	1-引入持久连接（`Connection: keep-alive`），即 tcp 连接默认不会关闭，可以被多次请求复用；

​	2-允许同一个 tcp 连接中同时发起多个请求，但是同一个 tcp 连接中，请求处理时按顺序执行的；

​	3-引入新的响应头和请求头：

​		缓存策略：cache-control：max-age；

​	4-新的请求方式，例如：put、options、delete；

http2.0：

​	1-多路复用：在一个 tcp 连接中，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，避免“**队头阻塞**”；

​	2-二进制分帧：不同于 1.X 中的文本格式，2.0 中采用二进制传输数据，可以把数据分成更小的帧，这些数据帧格式是确定的，所以可以乱序发送，接收方可以按照帧格式重新组装，这也是多路复用的基础；

​	3-首部压缩：2.0 中使用“首部表”来存储之前已经发送的请求头，对于相同的数据，不会再发送该请求头；

​	4-服务端推送：允许服务端推送 **静态资源** 给客户端，例如在客户端请求页面中，顺便把需要的 **css、图片等静态资源** 推送给客户端，而不需要客户端再次请求；

## 4-如何实现共享登录状态？实现单点登录

1-同域名通过 cookie 实现：原理：父域名的 cookie 会被子域名共享，那么我只需要将 登录后的 cookie domain 设置为夫域名就可以。

​	例如：domain 设置为 ccsu.cool，那么 jwxtxzs.ccsu.cool 和 manage.ccsu.cool 就可以实现登录状态共享。

2-不同域名：可以将用户信息工作安排到单独的认证中心，每次客户端去访问应用的时候，**都需要通过认证中心的验证**，验证通过后发一个 **加密的、有时效性的 token** 给客户端。在这之后客户端去访问其他应用都在 url 上携带 token，应用程序会先移交给 **认证中心验证**，验证无误后且没有超时后放行，**应用程序把这个 token 写入 客户端 cookie**，只有携带这个 cookie **不需要认证中心参与**，可以实现登录验证。

## 5-说一说 JWT 鉴权？

jwt：**json web token**，一串字符串，三个部分组成，**头部（Header）、载荷（Payload）、签名（Signature）**，用‘**.**’分隔。其中 header、payload 已 **json 格式** 存放的数据，不过都会编码成字符串，然后签名是依照 header、payload 内容，**通过密钥加密编码生成的字符串**，一旦前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名不一致。

优点：

​	1-组成简单，字节占用小，便于传输；

​	2-服务端无需保存会话信息，节约资源，很容易进行水平扩展；

​	3-一处生成，多处使用，可以解决单点登录问题；

​	4-可防护CSRF攻击；

缺点：

​	1-payload部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息；

​	2-需要保护好加密密钥，一旦泄露后果不堪设想；

​	3-防止 token 被挟持，可以使用 https；

**前端如何保存 token** :

​	在前端接收到 token 后，一般情况会通过 **localStorage** 进行缓存，然后将 token 放到HTTP请求头 **Authorization** 中，关于Authorization 的设置，前面要加上 **Bearer** ，注意后面带有空格。