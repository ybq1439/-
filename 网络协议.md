## \## 1-get 请求与 post 请求的区别？

1-使用场景不同：get 请求用于向服务端获取资源，一般不会对服务端造成影响，Post 请求一般用于提交数据，可能会对服务端造成影响；

2-规范的`get`请求时安全且幂等的，所以浏览器会主动缓存 get 请求；

3-报文格式方面，get 请求的 body 为空，而 post 请求，body 中一般就是向服务端传递的数据；get 请求也可以通过 url 传递数据；get 请求因为使用 url 携带参数，**url长度会被服务端限制**，post 不会有长度限制；

4-参数数据类型：get 只接受 ASCII 字符，而 post 可以是很多类型没有限制；

安全性：http 明文传输都是不安全的，https 才安全；

## \## 2-SSL 连接断开，如何恢复？

1-使用 sessionId：下一次重新连接的时候，只需要客户端携带上正确的 sessionId，服务端有记录，那么还是可以使用上一次的密钥；缺点是 sessionId 是存在与服务器上的，如果请求转移到的别的服务器上，就无法恢复；

2-使用 session ticket：session ticket 服务端发送给客户端，这个 ticket 只有服务端可以解密，这样的会，如果请求到别的服务器上，也是可以恢复对话的。

## \## 3-http1.0、http1.1、http2.0 的区别？

http1.0：浏览器与服务器只保持短暂的连接，浏览器每一次请求都需要重新建立连接；

http1.1：

  1-**持久连接**（`Connection: keep-alive`），即 tcp 连接默认不会关闭，可以被多次请求复用；

  2-**管道化**：允许同一个 tcp 连接中同时发起 **多个请求**，但是同一个 tcp 连接中，请求处理时按顺序执行的；

  3-引入新的响应头和请求头：

​    缓存策略：新的强缓存策略 cache-control：max-age；

  4-新的 **请求方式**，例如：put、options、delete；

http2.0：

  1-**多路复用**：在一个 tcp 连接中，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，避免“**队头阻塞**”；

 2-**二进制分帧**：不同于 1.X 中的文本格式，2.0 中采用二进制格式传输数据，帧是`http2`通信中最小单位信息。优点：1-二进制格式相比文本格式，解析起来更加高效；2-`数据流`都是按照`消息`的形式发送，而一个消息是由一个或者多个帧组成，多个帧之间可以乱序发送，我们只需要根据帧首部的流标识进行重新组装就可以得到正确数据，这也是多路复用能够同时发送数据的实现条件。

  3-**首部压缩**：2.0 中使用“首部表”来存储之前已经发送的请求头，对于相同的数据，不会再发送该请求头；

  4-**服务端推送静态数据**：允许服务端推送 **静态资源** 给客户端，例如在客户端请求页面中，顺便把需要的 **css、图片等静态资源** 推送给客户端，而不需要客户端再次请求；

## \## 4-如何实现共享登录状态？实现单点登录

1-同域名通过 cookie 实现：原理：父域名的 cookie 会被子域名共享，那么我只需要将 登录后的 cookie domain 设置为父域名就可以。

  例如：domain 设置为 ccsu.cool，那么 jwxtxzs.ccsu.cool 和 manage.ccsu.cool 就可以实现登录状态共享。

2-不同域名：可以将用户信息工作安排到单独的认证中心，每次客户端去访问应用的时候，**都需要通过认证中心的验证**，验证通过后发一个 **加密的、有时效性的 token** 给客户端。在这之后客户端去访问其他应用都在 url 上携带 token，应用程序会先移交给 **认证中心验证**，验证无误后且没有超时后放行，**应用程序把这个 token 写入 客户端 cookie**，只要携带这个 cookie 不需要认证中心参与，可以实现登录验证。

## \## 5-说一说 JWT （json web token）鉴权？

实现 JWT 话，大概过程是这样的，就是登录验证通过，服务端会返回一个 **token** 给客户端，然后有了这个 token 客户端就有权限访问服务了。

**token** 是一串字符串，三个部分组成，**头部（Header）、载荷（Payload）、签名（Signature)，用 ‘.’ 分隔**。其中 header、payload 以 json 格式存放的数据，不过都会编码成字符串，然后签名是依照 header、payload 内容，**通过密钥加密编码生成的字符串**，一旦前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名不一致。

优点：

  1-组成简单，字节占用小，便于传输；

  2-服务端无需保存会话信息，节约资源，很容易进行水平扩展；

  3-一处生成，多处使用，可以解决单点登录问题；

  4-可防护CSRF攻击；

缺点：

  1-payload部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息；

  2-需要保护好加密密钥，一旦泄露后果不堪设想；

  3-防止 token 被挟持，可以使用 https；

**前端如何保存 token** :

  在前端接收到 token 后，一般情况会通过 **localStorage** 进行缓存，然后将 token 放到HTTP请求头 **Authorization** 中，关于Authorization 的设置，前面要加上 **Bearer** ，注意后面带有空格。

## \## 6-http1.0、http1.1、http2.0  提高传输效率的发展历程？

[Http系列(二) Http2中的多路复用 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903935648497678#heading-6)

  多个 TCP 连接---》keep-alive---》管道化---》多路复用

## \## 7-正向代理和反向代理？

正向代理：正向代理隐藏真实的客户端，客户端请求的服务都被代理服务器代替请求；

反向代理：反向代理隐藏真实的服务端，请求一个网站的时候，可能会有成千上万的服务器为我们服务，但是我们之只需要直到代理服务是谁就可以，反向代理服务器会将请求转发到真实服务器。反向代理服务器一般用来实现 **负载平衡**。

## \## 8-实现负载平衡？

1-使用反向代理实现，所有请求都发到反向代理服务器上，代理服务器转发请求到真实服务器；

2-通过 DNS 实现，一般大型网站一个域名都会对应多个服务器地址，用户访问的时候，DNS 服务器返回这个域名对用的服务器 IP 集合，应答会改变 IP 集合顺序，用户就可以访问到不同的服务器上，实现负载平衡。由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解析仍然返回的是那个 IP 地址，就会造成访问的问题。

## \## 9-options 请求的作用？

options 请求叫做预检请求，主要是用于 **请求嗅探**，比如用于检查服务端资源支持的请求类型。还有 CROS 实现跨域资源共享就是先通过 options 请求，判断是否有访问权限。

## ##10-实时通讯 长轮询、短轮询、SSE、WebSocket 的区别？

1-短轮询：客户端每隔一段时间就向服务端请求，服务端收到请求后就会返回最新的数据；缺点：请求频率比较高，浪费资源，如果用户很多，服务器压力大很；

2-长轮询：客户端发起请求，服务端不会立刻返回响应，会把请求挂起，当有数据更新时才返回响应，或者说请求超过一定时间也会返回响应；相比短轮询优点：**减少请求次数**；缺点：挂起请求也会浪费资源；

3-SSE（sever-sent-events）：基于 http 协议，服务端通过流数据向客户端推送消息。大概过程是这样的，首先 **服务端向客户端说明接下来要传输流数据**，是一个数据流，**客户端就不会关闭连接**，一直等待数据传输完成；

缺点：IE 不兼容。SSE 的方式是 **单向通信** 的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。

4-webSocket：HTML5 中提出新协议，上面都是基于 **HTTP** 协议。

## ##11-状态码？

#### 分类

​	1系列：表示消息，一般是临时响应；

​	2系列：表示成功；

​	3系列：表示重定向；

​	4系列：请求出错；

​	5系列：服务端错误；

#### 	常见状态码

​	200：请求完成，需要的数据也都返回；

​	301：网站已经永久重定向，用于新域名替换旧域名时使用；

​	302：临时重定向，比如需要用户登录，重定向到登录页面；

​	304：协商缓存使用，告诉客户端使用缓存；

​	401：需要进行登录验证；

​	403：禁止访问，比如使用外网 ip 访问公司内部网络就可能被禁止；

​	404：请求的资源不存在；

​	504：网关超时；

## ##12-tcp 报文格式？

### 	1-标志位字段：

#### 		(1)ACK：应答上一次报文是否收到了，是否有效；

#### 		(2)SYN：在建立链接的时候使用，当`SYN`等于1，表明这是一个请求建立连接的报文，或者是一个同意建立连接的报文；只会在前两次握手的时候出现。

#### 		(3)FIN：标记数据是否完成发送，`FIN=1`，表示数据已经发送完成，可以释放连接了。

## ##13-http协议常用头部字段？

#### 	1-host：客户端发送请求时，用来指定服务器的域名；有了 `Host` 字段，就可以将请求发往「同一台」服务器上的不同网站。

#### 	2-content-length：服务器在返回数据的时候，会有这个字段，表明此次回应的`body`的长度；

​		解决粘包问题：1-`http`协议通过设置回车、换行作为 `http header`的边界；2-通过`content-length`字段设置`http body`的边界，这两种方式都是用来解决粘包的。

		什么是粘包问题：粘包问题发生在 TCP/IP 协议中，因为 TCP 是面向连接的传输协议，它是以 流 stream 的形式传输数据的，而 流 数据是没有明确数据的开始和结尾边界的，所以就会导致原本的连个数据包A，B 传过来是AB，区分不出。

#### 	3-Connection：字段最常用于客户端要求服务器使用「 HTTP 长连接」机制，以便其他请求复用。

​	HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

​	`HTTP/1.1` 版本的默认连接都是`长连接`，但为了兼容老版本的 HTTP，需要指定 `Connection` 首部字段的值为 `Keep-Alive`。

#### 	4-content-type：字段用于服务端回应时，告诉客户端，本次数据使用什么格式。

```text
Content-Type: text/html; charset=utf-8
```

#### 	5-content-encoding：字段说明数据的压缩方法。表明服务器返回的数据，使用什么格式的压缩方法。

```text
Content-Encoding: gzip
```

## ##14-DNS 协议？

## ##15-Rpc 协议地址解析协议。

## ##16-浏览器缓存?

### 	1-强缓存错误的设置了过长时间，怎么办？

### 	2-被中间人攻击了，怎么办？

​		检查对方证书，操作系统不去信任不明证书就可以了。

### 	3-缓存控制的字段？

## ##17-能否详细解释一下 http 超文本传输协议?

可以拆成三大部分：超文本《--传输--》协议。

1-超文本：传输的内容是超文本：它就是**超越了普通文本的文本**，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。像我们的`HTML`就是一种超文本，虽然它本身都是纯文本文件，但是内部用来很多标签能够定义图片、视频等链接，再经过浏览器的解释，就呈现出有文本、有画面的网页了。

2-传输：http是在两点之间传输数据的约定和规范。

3-协议：http是一种计算机世界的协议，我是这么理解的，协议就是使得计算机之间都能够互相理解从而进行交流沟通，的一种约定和规范。

## ##18-GET 和 POST 方法都是安全和幂等的吗?

- 在 HTTP 协议里，所谓的「安全」是指请求方法**不会「破坏」服务器**上的资源。
- 所谓的「幂等」，意思是多次执行相同的操作，**结果都是「相同」的**。

​	从 RFC【request for comments 请求协议】 规范定义的语义来看：

- **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，**可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签**。
- **POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。所以，**浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签**。

但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：

- 可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。
- 可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。

## ##19.GET 请求可以带 body 吗？?

RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。

另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。

## ##20.Http 缓存机制？

对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都**缓存在本地**，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。

HTTP 缓存有两种实现方式，分别是**强制缓存和协商缓存**。

### 什么是强缓存？

强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的**主动性在于浏览器这边。**

- `Cache-Control`， 是一个相对时间；

- `Expires`，是一个绝对时间；

  如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，**Cache-Control 的优先级高于 Expires** 。

  Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：

  - 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；
  - 浏览器再次请求访问服务器中的该资源时，会先**通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器；
  - 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control；

### 什么是协商缓存

**协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存**。

- Last-Modified，If-Modified-Since；
- Etag，If-None-Match；
- **Etag 的优先级更高**
- **为什么 ETag 的优先级更高？**这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题：
  1. 在没有修改文件内容情况下文件的**最后修改时间可能也会改变**，这会导致客户端认为这文件被改动了，从而重新请求；
  2. 可能有些文件是在**秒级以内修改的**，`If-Modified-Since` 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；
  3. 有些服务器**不能精确获取文件的最后修改时间**。

注意，**协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**。

## ##21.HTTP/1.1 的优点有哪些？

### *1. 简单*:

HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，**易于理解**，降低了学习和使用的门槛。

### *2. 灵活和易于扩展*:

HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员**自定义和扩充**。

同时 HTTP 由于是工作在应用层（ `OSI` 第七层），则它**下层可以随意变化**，比如：

- HTTPS 就是在 HTTP 与 TCP 层之间**增加了 SSL/TLS 安全传输层**；
- HTTP/1.1 和 HTTP/2.0 传输协议使用的是 TCP 协议，而到了 HTTP/3.0 传输协议改用了 UDP 协议。

### *3. 应用广泛和跨平台*:

互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用遍地开花，同时天然具有**跨平台**的优越性。

## ##22.HTTP/1.1 的缺点有哪些？

HTTP 协议里有优缺点一体的**双刃剑**，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。

### *1. 无状态双刃剑*

无状态的**好处**，服务器不会去记忆 HTTP 的状态，不需要额外的资源来**记录状态信息**，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。

无状态的**坏处**，既然服务器没有记忆能力，它在完成有**关联性的操作时**会非常麻烦。

例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。

### *2. 明文传输双刃剑*

明文意味着在传输过程中的信息，是可方便阅读的，比如我们使用抓包工具都可以直接肉眼查看，为我们调试工作带了极大的便利性。

但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于**信息裸奔**。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那**你号没了**。

### *3. 不安全*

HTTP 比较严重的缺点就是不安全：

- 通信使用明文（不加密），内容可能会被窃听。比如，**账号信息容易泄漏，那你号没了。**
- 不验证通信方的身份，因此有可能遭遇伪装。比如，**访问假的淘宝、拼多多，那你钱没了。**
- 无法验证报文的完整性，所以有可能已遭篡改。比如，**网页上植入垃圾广告，视觉污染，眼没了。**

HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。

## 23.HTTP/1.1 的性能如何？

HTTP 协议是基于 **TCP/IP**，并且使用了「**请求 - 应答**」的通信模式，所以性能的关键就在这**两点**里。

### *1. 长连接*

早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是**串行请求**，做了无谓的 TCP 连接建立和断开，增加了通信开销。

为了解决上述 TCP 连接问题，HTTP/1.1 提出了**长连接**的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。

持久连接的特点是，**只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。**当然，如果某个 HTTP 长连接**超过一定时间**没有任何数据交互，服务端就会**主动断开这个连接**。

### *2. 管道网络传输*

HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**

但是**服务器必须按照接收请求的顺序发送对这些管道化请求的响应**。如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。所以，**HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞**。

### *3. 队头阻塞*

「请求 - 应答」的模式会造成 HTTP 的性能问题。为什么呢？

因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「**队头阻塞**」，好比上班的路上塞车。

总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。

## 24.HTTP 与 HTTPS 有哪些区别？

- HTTP 是超文本传输协议，信息是**明文传输**，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP【传输层】 和 HTTP 之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，**还需进行 SSL/TLS 的握手过程**，才可进入加密报文传输。
- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

## 25.HTTPS 解决了 HTTP 的哪些问题？

1. ### **窃听风险**，比如通信链路上可以获取通信内容，用户号容易没。解决方法：**信息加密**

2. ### **篡改风险**，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。解决方法：**校验机制，信息篡改了就无法正常显示**

3. ### **冒充风险**，比如冒充淘宝网站，用户钱容易没。解决方法：**身份证书**

4. ### HTTPS 是如何解决上面的三个风险的？

   - **混合加密**的方式实现信息的**机密性**，解决了窃听的风险。
     - 在通信建立前采用**非对称加密**的方式交换「会话秘钥」，后续就不再使用非对称加密。
     - 在通信过程中全部使用**对称加密**的「会话秘钥」的方式加密明文数据。
   - **摘要算法**的方式来实现**完整性**，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
   - 将服务器公钥放入到**数字证书**中，解决了冒充的风险。

   

### 1.采用「混合加密」的方式的原因：

- **对称加密**只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
- **非对称加密**使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。

### 2.*摘要算法【哈希函数】 + 数字签名*【非对称算法】：

### 	通过哈希算法来保证消息的完整性；

### 	可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；

- 摘要算法：依据内容**用摘要算法（哈希函数）来计算出哈希值**，也就是内容的「指纹」，这个**哈希值是唯一的，且无法通过哈希值推导出内容**。然后与内容一起发给客户端，客户端收到后，依据内容也生成哈希值，然后对比是否一致，一致则可以确认内容没有被篡改。

  **但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明**。

  所以用到**非对称加密算法**来解决这个问题。

  服务端会首先把公钥发送给客户端，然后使用私钥加密生成的哈希值，客户端收到消息后，如果可以使用公钥解开哈希值，那么可以证明这就是服务端发过来的消息。

### 3.数字证书：

​	但是这还远远不够，**还缺少身份验证的环节**，万一公钥是被伪造的呢？为了证明公钥是正确的，CA（数字证书认证机构）机构会将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。

## 26.cookie如何跨域？

1. 从cookie层面解决：设置cookie的domain属性；

2. 从http请求头解决：前端请求设置fetch 的`witdhCredentials`属性为`true`，同时后端需要相关的`cors`，首先需要允许跨域请求：

   ```js
   // node.js express 框架示例
   app.use(function(req, res, next) {
     res.header('Access-Control-Allow-Origin', 'http://localhost:8080'); // 允许跨域请求的源
     res.header('Access-Control-Allow-Credentials', 'true'); // 允许跨域请求携带 Cookie
     res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS'); // 允许跨域请求的方法
     res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization, Content-Length, X-Requested-With'); // 允许跨域请求的请求头
     next();
   });
   //前端设置
   fetch('http://example.com/api/data', {
     method: 'GET',
     credentials: 'include' // 允许跨域请求携带 Cookie
   }).then(response => {
     // 处理响应
   });
   
   ```

   