## \## 1-get 请求与 post 请求的区别？

1-使用场景不同：get 请求用于向服务端获取资源，一般不会对服务端造成影响，Post 请求一般用于提交数据，可能会对服务端造成影响；

2-使用场景不同，所以浏览器会主动缓存 get 请求；

3-报文格式方面，get 请求的 body 为空，而 post 请求，body 中一般就是向服务端传递的数据；get 请求也可以通过 url 传递数据；get 请求因为使用 url 携带参数，而浏览器会限制 url 长度，所以参数多少是有限制的，post 不会有长度限制；

4-参数数据类型：get 只接受 ASCII 字符，而 post 可以是很多类型没有限制；

5-安全性方面，post 相比与 get 更加安全，因为 get 请求的参数直接暴露在 url 上；

6-浏览器保存浏览记录的时候，会把 get 请求携带的 **参数** 也保存下来，post 请求不会；

安全性：http 明文传输都是不安全的，https 才安全；

## \## 2-SSL 连接断开，如何恢复？

1-使用 sessionId：下一次重新连接的时候，只需要客户端携带上正确的 sessionId，服务端有记录，那么还是可以使用上一次的密钥；缺点是 sessionId 是存在与服务器上的，如果请求转移到的别的服务器上，就无法恢复；

2-使用 session ticket：session ticket 服务端发送给客户端，这个 ticket 只有服务端可以解密，这样的会，如果请求到别的服务器上，也是可以恢复对话的。

## \## 3-http1.0、http1.1、http2.0 的区别？

http1.0：浏览器与服务器只保持短暂的连接，浏览器每一次请求都需要重新建立连接；

http1.1：

  1-**持久连接**（`Connection: keep-alive`），即 tcp 连接默认不会关闭，可以被多次请求复用；

  2-**管道化**：允许同一个 tcp 连接中同时发起 **多个请求**，但是同一个 tcp 连接中，请求处理时按顺序执行的；

  3-引入新的响应头和请求头：

​    缓存策略：新的强缓存策略 cache-control：max-age；

  4-新的 **请求方式**，例如：put、options、delete；

http2.0：

  1-**多路复用**：在一个 tcp 连接中，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，避免“**队头阻塞**”；

 2-**二进制分帧**：不同于 1.X 中的文本格式，2.0 中采用二进制格式传输数据，帧是`http2`通信中最小单位信息。优点：1-二进制格式相比文本格式，解析起来更加高效；2-`数据流`都是按照`消息`的形式发送，而一个消息是由一个或者多个帧组成，多个帧之间可以乱序发送，我们只需要根据帧首部的流标识进行重新组装就可以得到正确数据，这也是多路复用能够同时发送数据的实现条件。

  3-**首部压缩**：2.0 中使用“首部表”来存储之前已经发送的请求头，对于相同的数据，不会再发送该请求头；

  4-**服务端推送静态数据**：允许服务端推送 **静态资源** 给客户端，例如在客户端请求页面中，顺便把需要的 **css、图片等静态资源** 推送给客户端，而不需要客户端再次请求；

## \## 4-如何实现共享登录状态？实现单点登录

1-同域名通过 cookie 实现：原理：父域名的 cookie 会被子域名共享，那么我只需要将 登录后的 cookie domain 设置为父域名就可以。

  例如：domain 设置为 ccsu.cool，那么 jwxtxzs.ccsu.cool 和 manage.ccsu.cool 就可以实现登录状态共享。

2-不同域名：可以将用户信息工作安排到单独的认证中心，每次客户端去访问应用的时候，**都需要通过认证中心的验证**，验证通过后发一个 **加密的、有时效性的 token** 给客户端。在这之后客户端去访问其他应用都在 url 上携带 token，应用程序会先移交给 **认证中心验证**，验证无误后且没有超时后放行，**应用程序把这个 token 写入 客户端 cookie**，只要携带这个 cookie 不需要认证中心参与，可以实现登录验证。

## \## 5-说一说 JWT （json web token）鉴权？

实现 JWT 话，大概过程是这样的，就是登录验证通过，服务端会返回一个 **token** 给客户端，然后有了这个 token 客户端就有权限访问服务了。

**token** 是一串字符串，三个部分组成，**头部（Header）、载荷（Payload）、签名（Signature)，用 ‘.’ 分隔**。其中 header、payload 以 json 格式存放的数据，不过都会编码成字符串，然后签名是依照 header、payload 内容，**通过密钥加密编码生成的字符串**，一旦前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名不一致。

优点：

  1-组成简单，字节占用小，便于传输；

  2-服务端无需保存会话信息，节约资源，很容易进行水平扩展；

  3-一处生成，多处使用，可以解决单点登录问题；

  4-可防护CSRF攻击；

缺点：

  1-payload部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息；

  2-需要保护好加密密钥，一旦泄露后果不堪设想；

  3-防止 token 被挟持，可以使用 https；

**前端如何保存 token** :

  在前端接收到 token 后，一般情况会通过 **localStorage** 进行缓存，然后将 token 放到HTTP请求头 **Authorization** 中，关于Authorization 的设置，前面要加上 **Bearer** ，注意后面带有空格。

## \## 6-http1.0、http1.1、http2.0  提高传输效率的发展历程？

[Http系列(二) Http2中的多路复用 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903935648497678#heading-6)

  多个 TCP 连接---》keep-alive---》管道化---》多路复用

## \## 7-正向代理和反向代理？

正向代理：正向代理隐藏真实的客户端，客户端请求的服务都被代理服务器代替请求；

反向代理：反向代理隐藏真实的服务端，请求一个网站的时候，可能会有成千上万的服务器为我们服务，但是我们之只需要直到代理服务是谁就可以，反向代理服务器会将请求转发到真实服务器。反向代理服务器一般用来实现 **负载平衡**。

## \## 8-实现负载平衡？

1-使用反向代理实现，所有请求都发到反向代理服务器上，代理服务器转发请求到真实服务器；

2-通过 DNS 实现，一般大型网站一个域名都会对应多个服务器地址，用户访问的时候，DNS 服务器返回这个域名对用的服务器 IP 集合，应答会改变 IP 集合顺序，用户就可以访问到不同的服务器上，实现负载平衡。由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解析仍然返回的是那个 IP 地址，就会造成访问的问题。

## \## 9-options 请求的作用？

options 请求叫做预检请求，主要是用于 **请求嗅探**，比如用于检查服务端资源支持的请求类型。还有 CROS 实现跨域资源共享就是先通过 options 请求，判断是否有访问权限。

## ##10-实时通讯 长轮询、短轮询、SSE、WebSocket 的区别？

1-短轮询：客户端每隔一段时间就向服务端请求，服务端收到请求后就会返回最新的数据；缺点：请求频率比较高，浪费资源，如果用户很多，服务器压力大很；

2-长轮询：客户端发起请求，服务端不会立刻返回响应，会把请求挂起，当有数据更新时才返回响应，或者说请求超过一定时间也会返回响应；相比短轮询优点：**减少请求次数**；缺点：挂起请求也会浪费资源；

3-SSE（sever-sent-events）：基于 http 协议，服务端通过流数据向客户端推送消息。大概过程是这样的，首先 **服务端向客户端说明接下来要传输流数据**，是一个数据流，**客户端就不会关闭连接**，一直等待数据传输完成；

缺点：IE 不兼容。SSE 的方式是 **单向通信** 的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。

4-webSocket：HTML5 中提出新协议，上面都是基于 **HTTP** 协议。

## ##11-状态码？

#### 分类

​	1系列：表示消息，一般是临时响应；

​	2系列：表示成功；

​	3系列：表示重定向；

​	4系列：请求出错；

​	5系列：服务端错误；

#### 	常见状态码

​	200：请求完成，需要的数据也都返回；

​	301：网站已经永久重定向，用于新域名替换旧域名时使用；

​	302：临时重定向，比如需要用户登录，重定向到登录页面；

​	304：协商缓存使用，告诉客户端使用缓存；

​	401：需要进行登录验证；

​	403：禁止访问，比如使用外网 ip 访问公司内部网络就可能被禁止；

​	404：请求的资源不存在；

​	504：网关超时；

## ##12-tcp 报文格式？

### 	1-标志位字段：

#### 		(1)ACK：应答上一次报文是否收到了，是否有效；

#### 		(2)SYN：在建立链接的时候使用，当`SYN`等于1，表明这是一个请求建立连接的报文，或者是一个同意建立连接的报文；只会在前两次握手的时候出现。

#### 		(3)FIN：标记数据是否完成发送，`FIN=1`，表示数据已经发送完成，可以释放连接了。

## ##13-http协议常用头部字段？

#### 	1-host：客户端发送请求时，用来指定服务器的域名；有了 `Host` 字段，就可以将请求发往「同一台」服务器上的不同网站。

#### 	2-content-length：服务器在返回数据的时候，会有这个字段，表明此次回应的`body`的长度；

​		解决粘包问题：1-`http`协议通过设置回车、换行作为 `http header`的边界；2-通过`content-length`字段设置`http body`的边界，这两种方式都是用来解决粘包的。

​		什么是粘包问题：

#### 	3-Connection：字段最常用于客户端要求服务器使用「 HTTP 长连接」机制，以便其他请求复用。

​	HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

​	`HTTP/1.1` 版本的默认连接都是`长连接`，但为了兼容老版本的 HTTP，需要指定 `Connection` 首部字段的值为 `Keep-Alive`。

#### 	4-content-type：字段用于服务端回应时，告诉客户端，本次数据使用什么格式。

```text
Content-Type: text/html; charset=utf-8
```

#### 	5-content-encoding：字段说明数据的压缩方法。表明服务器返回的数据，使用什么格式的压缩方法。

```text
Content-Encoding: gzip
```

## ##14-DNS 协议？

## ##15-Rpc 协议地址解析协议。

## ##16-浏览器缓存?

### 	1-强缓存错误的设置了过长时间，怎么办？

### 	2-被中间人攻击了，怎么办？

​		检查对方证书，操作系统不去信任不明证书就可以了。

### 	3-缓存控制的字段？

​	